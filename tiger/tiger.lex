(*For this, I took reference from Reverse-Polish Compiler from Sir's Compiler GitLab Repository*)
type lineNo = int
type pos = int

(* Keeps the track of the line number *)
val lineRef : pos ref = ref 0

(* 
Since Tiger Language supports nestied comments, the check for proper nesting is done in
Lexing phase itself. And so, the the count is keep about what depth of Lexing are we in 
*)
val nestComment : int ref = ref 0

(* 
This is used to keep track of the string, when we are in the state of string.
We needed to break it into states in order to handle the precence of special characters in the string
*)
val strIn : string ref = ref "";

(* Concatinates the present string with string a *)
fun insertStr a (s:string ref) = (s := !s ^ a );

(* Updates the line number we are in *)
fun UpdateLine n = lineRef := !(lineRef) + n

(* Stuff done to make use of Tokens module generated by expr.grm *)
type svalue        = Tokens.svalue
type ('a,'b) token = ('a,'b) Tokens.token
type lexresult     = (svalue,pos) token

(* Printing the error *)
fun lineRange l r = "line " ^ Int.toString(l)
fun error (e,l,r) = TextIO.output(TextIO.stdErr, lineRange l r ^ ":" ^ e ^ "\n")

(* When we reach eof, we put the lineRef to 0, since if we directly run it next time, the lineNumber
would start from where it stopped *)
fun eof   ()      = (lineRef := 0 ;Tokens.EOF (!lineRef,!lineRef))


(* Some helper functions during lexing *)

fun charsToInt m (x :: xs) = charsToInt (10 * m + ord x - ord #"0") xs
  | charsToInt m []        = m

fun toSigned (#"-" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"~" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"+" :: xs) =   charsToInt 0 xs
  | toSigned xs           =   charsToInt 0 xs

val toInt        = toSigned o String.explode

(* Updates line number based on the \n's encountered *)
val newlineCount = List.length o List.filter (fn x => x = #"\n") o String.explode



%%

%header (functor ExprLexFun(structure Tokens : Expr_TOKENS));
ws    = [\ \t];
digit = [0-9];
id = [a-zA-Z][a-zA-Z0-9_]*;
%s COMMENT STRING; 


%%


<INITIAL>"/*" => (YYBEGIN COMMENT; nestComment := 1 ;continue());
<COMMENT>"*/" => (nestComment := !nestComment -1; if (!nestComment =0) then YYBEGIN INITIAL else if (!nestComment <0) then error("Comments not closed properly",!lineRef,!lineRef) else  ();continue());
<COMMENT>"/*" => (nestComment := !nestComment +1; continue());
<COMMENT>[^"*/""/*"]*   =>  ( let val old = !lineRef
                              in UpdateLine (newlineCount yytext); continue()
                              end
                            );

<COMMENT>"\"" => (continue());
<COMMENT>"\'" => (continue());

<INITIAL>[\t\ \n]*  => ( let val old = !lineRef
                         in UpdateLine (newlineCount yytext); continue()
                         end
                       );

<INITIAL>{digit}+ => ( Tokens.CONST_INT (toInt yytext, !lineRef, !lineRef) );
<INITIAL>"+"      => ( Tokens.PLUS  (!lineRef,!lineRef) );
<INITIAL>"-"      => ( Tokens.MINUS  (!lineRef,!lineRef) );
<INITIAL>"*"      => ( Tokens.MUL (!lineRef,!lineRef) );
<INITIAL>"nil"    => ( Tokens.NIL (!lineRef,!lineRef));
<INITIAL>"for"    => ( Tokens.FOR (!lineRef,!lineRef));
<INITIAL>"-"      => (Tokens.MINUS (!lineRef,!lineRef));
<INITIAL>"*"      => (Tokens.MUL (!lineRef,!lineRef));
<INITIAL>"/"      => (Tokens.DIVIDE (!lineRef,!lineRef));
<INITIAL>"("      => (Tokens.LBRAC_R (!lineRef,!lineRef));
<INITIAL>")"      => (Tokens.RBRAC_R (!lineRef,!lineRef));
<INITIAL>"["      => (Tokens.LBRAC_SQ (!lineRef,!lineRef));
<INITIAL>"]"      => (Tokens.RBRAC_SQ (!lineRef,!lineRef));
<INITIAL>";"      => (Tokens.SEMICOLON (!lineRef,!lineRef));
<INITIAL>"while"  => (Tokens.WHILE (!lineRef,!lineRef));
<INITIAL>"if"     => (Tokens.IF (!lineRef,!lineRef));
<INITIAL>"for"    => (Tokens.FOR (!lineRef,!lineRef));
<INITIAL>"let"    => (Tokens.LET (!lineRef,!lineRef));
<INITIAL>"array"  => (Tokens.ARRAY (!lineRef,!lineRef));
<INITIAL>"then"   => (Tokens.THEN (!lineRef,!lineRef));
<INITIAL>"else"   => (Tokens.ELSE (!lineRef,!lineRef));
<INITIAL>"end"    => (Tokens.END (!lineRef,!lineRef));
<INITIAL>"function"  => (Tokens.FUNCTION (!lineRef,!lineRef));
<INITIAL>":"      => (Tokens.COLON (!lineRef,!lineRef));
<INITIAL>","      => (Tokens.COMMA (!lineRef,!lineRef));
<INITIAL>"."      => (Tokens.DOT (!lineRef,!lineRef));
<INITIAL>"="      => (Tokens.EQ (!lineRef,!lineRef));
<INITIAL>"<"      => (Tokens.LT (!lineRef,!lineRef));
<INITIAL>">"      => (Tokens.GT (!lineRef,!lineRef));
<INITIAL>"<="     => (Tokens.LTE (!lineRef,!lineRef));
<INITIAL>">="     => (Tokens.GTE (!lineRef,!lineRef));
<INITIAL>"<>"     => (Tokens.NEQ (!lineRef,!lineRef));
<INITIAL>":="     => (Tokens.ASSIGN (!lineRef,!lineRef));
<INITIAL>"|"      => (Tokens.OR (!lineRef,!lineRef));
<INITIAL>"&"      => (Tokens.AND (!lineRef,!lineRef));
<INITIAL>"var"    => (Tokens.VAR (!lineRef,!lineRef));
<INITIAL>"type"   => (Tokens.TYPE (!lineRef,!lineRef));
<INITIAL>"in"     => (Tokens.IN (!lineRef,!lineRef));
<INITIAL>"of"     => (Tokens.OF (!lineRef,!lineRef));
<INITIAL>"break"  => (Tokens.BREAK (!lineRef,!lineRef));
<INITIAL>"to"     => (Tokens.TO (!lineRef,!lineRef));   
<INITIAL>"do"     => (Tokens.DO (!lineRef,!lineRef));
<INITIAL>"break"  => (Tokens.BREAK (!lineRef,!lineRef));
<INITIAL>{id}     => (Tokens.ID(yytext, !lineRef,!lineRef));
<INITIAL>"{"      => (Tokens.LBRAC_C(!lineRef,!lineRef));
<INITIAL>"}"      => (Tokens.RBRAC_C(!lineRef,!lineRef));
<INITIAL>"\""     => (strIn := "";YYBEGIN STRING; continue());
<STRING>[a-zA-Z0-9+]* => (insertStr yytext strIn ;continue());
<STRING>"\ "      => ((insertStr yytext strIn ;continue()));
<STRING>\n        => (insertStr "\n" strIn;continue());
<STRING>\t        => (insertStr "\t" strIn;continue());
<STRING>\\\"      => (insertStr "\"" strIn;continue());
<STRING>\\n       => (insertStr "\n" strIn;continue());
<STRING>\\\\      => (insertStr "\\" strIn;continue());
<STRING>"\""      => (YYBEGIN INITIAL; Tokens.CONST_STR(!strIn,!lineRef,!lineRef));
<STRING>"@"|"#"|"&"|"!"|"*"|"%"|"$"|"^"|"("|")"|"["|"]"|"{"|"}"|"."|"," => (insertStr yytext strIn ;continue());

